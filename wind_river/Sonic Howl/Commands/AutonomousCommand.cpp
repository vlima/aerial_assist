// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "AutonomousCommand.h"

AutonomousCommand::AutonomousCommand()
{
   // Use requires() here to declare subsystem dependencies
   // eg. requires(chassis);
   // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
   // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

// Called just before this Command runs the first time
void AutonomousCommand::Initialize()
{
   // Robot parts
   _left_front = RobotMap::chassisleft_front;
   _left_back = RobotMap::chassisleft_back;
   _right_front = RobotMap::chassisright_front;
   _right_back = RobotMap::chassisright_back;
   _arm = RobotMap::pickupArm;
   _roller_arm = RobotMap::pickupRollerArm;
   _rollers = RobotMap::pickupRollers;
   _lower_limit_switch = RobotMap::lowerLimitSwitch;
   _higher_limit_switch = RobotMap::higherLimitSwitch;
   _launcher = RobotMap::launcherLauncherController;
   gyro = RobotMap::pickupArmAngleGyro;
   gyro->Reset();

   // Preferences
   Preferences *prefs = Preferences::GetInstance();
   _positioning_count = prefs->GetDouble("auto-positioning-count", 12);
   _positioning_speed = prefs->GetDouble("auto-positioning-speed", 0.5);
   _extend_rollers_count = prefs->GetDouble("auto-extend-roller-count", 12);
   _extend_rollers_speed = prefs->GetDouble("auto-extend-roller-speed", 0.5);
   _extend_arm_count = prefs->GetDouble("auto-extend-arm-count", 12);
   _extend_arm_speed = prefs->GetDouble("auto-extend-arm-speed", 0.5);
   _pickup_move_count = prefs->GetDouble("auto-pickup-move-count", 12);
   _pickup_move_speed = prefs->GetDouble("auto-pickup-move-speed", -0.5);
   _pickup_roller_count = prefs->GetDouble("auto-pickup-roller-count", 20); // Make sure auto-pickup-roller-count >= auto-pickup-move-count !!!! 
   _aim_move_count = prefs->GetDouble("auto-aim-move-count", 12);
   _aim_move_speed = prefs->GetDouble("auto-aim-move-speed", 0.5);
   _aim_arm_count = prefs->GetDouble("auto-aim-arm-count", 12);
   _aim_arm_speed = prefs->GetDouble("auto-aim-arm-speed", -0.5);
   _aim_roller_count = prefs->GetDouble("auto-aim-roller-count", 12);
   _shoot_arm_count = prefs->GetDouble("auto-shoot-arm-count", 12);
   _shoot_arm_speed = prefs->GetDouble("auto-shoot-arm-speed", -0.5);
   _shoot_delay_count = prefs->GetDouble("auto-shoot-delay-count", 12);
   _shoot_speed = prefs->GetDouble("auto-shoot-speed", 0.5);

   // States
   _state = STATE_POSITIONING;
   _count = 0;
}

// Called repeatedly when this Command is scheduled to run
void AutonomousCommand::Execute()
{
   switch (_state)
   {
   case STATE_POSITIONING:
      PositioningState();
      break;

   case STATE_EXTEND_ARMS:
      ExtendArmsState();
      break;

   case STATE_PICKUP_BALL:
      PickupBallState();
      break;

   case STATE_AIM:
      AimState();
      break;

   case STATE_SHOOT:
      ShootState();
      break;

   case STATE_WINING_THE_GAME:
      WinningState();
      break;
   }

   Wait(0.25);
}

// Make this return true when this Command no longer needs to run execute()
bool AutonomousCommand::IsFinished()
{
   return false;
}
// Called once after isFinished returns true
void AutonomousCommand::End()
{

}
// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void AutonomousCommand::Interrupted()
{
}

void AutonomousCommand::SetArm(double speed)
{
   if ((!_lower_limit_switch->Get() && speed < 0) || (!_higher_limit_switch->Get() && speed > 0))
   {
      _arm->Set(0.0);
   }
   else
   {
      _arm->Set(speed);
   }
}

void AutonomousCommand::PositioningState()
{
   if (_count < _positioning_count)
   {
      _left_front->Set(_positioning_speed);
      _left_back->Set(_positioning_speed);
      _right_front->Set(_positioning_speed);
      _right_back->Set(_positioning_speed);
      _count++;
   }
   else
   {
      _count = 0;
      _state = STATE_EXTEND_ARMS;
   }
}

// Extend both rollers and picking arm. Not moving yet
void AutonomousCommand::ExtendArmsState()
{
   bool activity = false;

   // Extend rollers
   if (_count < _extend_rollers_count)
   {
      _roller_arm->Set(_extend_rollers_speed);
      activity = true;
   }

   // Extend arm. Careful with the lower limit!
   if (_count < _extend_arm_count && !_lower_limit_switch)
   {
      _arm->Set(_extend_arm_speed);
      activity = true;
   }

   if (activity)
   {
      // Still extending something
      _count++;
   }
   else
   {
      // Extension done
      _count = 0;
      _state = STATE_PICKUP_BALL;
   }
}

// Moves towards the ball while rolling the ball in
void AutonomousCommand::PickupBallState()
{
   bool activity = false;

   // Activate rollers
   if (_count < _pickup_roller_count)
   {
      _rollers->Set(Relay::kForward);
      activity = true;
   }

   // Moving towards the ball
   if (_count < _pickup_move_count)
   {
      _left_front->Set(_pickup_move_speed);
      _left_back->Set(_pickup_move_speed);
      _right_front->Set(_pickup_move_speed);
      _right_back->Set(_pickup_move_speed);
      activity = true;
   }

   if (activity)
   {
      // Still moving
      _count++;
   }
   else
   {
      // Pickup done
      _count = 0;
      _state = STATE_AIM;
   }
}

// Aims includes: * Position the ball inside the robot
//                * Move the robot to shooting position
void AutonomousCommand::AimState()
{
   bool activity = false;

   // Activate rollers
   if (_count < _aim_roller_count)
   {
      _rollers->Set(Relay::kForward);
      activity = true;
   }

   // Retract arm. Careful with the higher limit!
   if (_count < _aim_arm_count && !_higher_limit_switch)
   {
      _arm->Set(_aim_arm_speed);
      activity = true;
   }

   // Moving to shooting position
   if (_count < _aim_move_count)
   {
      _left_front->Set(_aim_move_speed);
      _left_back->Set(_aim_move_speed);
      _right_front->Set(_aim_move_speed);
      _right_back->Set(_aim_move_speed);
      activity = true;
   }

   if (activity)
   {
      // Still moving
      _count++;
   }
   else
   {
      // Pickup done
      _count = 0;
      _state = STATE_SHOOT;
   }
}

void AutonomousCommand::ShootState()
{
   // Activate launcher
   _launcher->Set(_shoot_speed);

   // Retract arm. Careful with the higher limit!
   if(_count < _shoot_arm_count)
   {
      if (_count > _shoot_delay_count && !_higher_limit_switch)
      {
         _arm->Set(_shoot_arm_speed);
      }
      _count++;
   }
   else
   {
      // Shoot done
      _count = 0;
      _state = STATE_WINING_THE_GAME;
   }
}

void AutonomousCommand::WinningState()
{
   // GO TEAM GO!!!
}
